{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Directive, Optional, Self, Inject, ChangeDetectorRef, ElementRef, Input, HostBinding, ViewChildren, HostListener, Component, ChangeDetectionStrategy, forwardRef, EventEmitter, Output, NgModule } from '@angular/core';\nimport { NgControl, FormsModule } from '@angular/forms';\nimport { EMPTY_QUERY, isNativeFocusedIn, clamp, quantize, round, tuiAssert, tuiDefaultProp, nonNegativeFiniteAssertion, tuiPure, TUI_FOCUSABLE_ITEM_ACCESSOR, typedFromEvent, TuiDestroyService, TuiRepeatTimesModule, TuiFocusableModule } from '@taiga-ui/cdk';\nimport { AbstractTuiSlider, SLIDER_KEYBOARD_STEP } from '@taiga-ui/kit/abstract';\nimport { TuiSliderComponent, TuiSliderModule } from '@taiga-ui/kit/components/slider';\nimport { TUI_FLOATING_PRECISION } from '@taiga-ui/kit/constants';\nimport { TUI_FROM_TO_TEXTS } from '@taiga-ui/kit/tokens';\nimport { tuiPercentageToKeyStepValue, tuiKeyStepValueToPercentage, tuiCheckKeyStepsHaveMinMaxPercents } from '@taiga-ui/kit/utils';\nimport { Observable, merge } from 'rxjs';\nimport { TuiFormatNumberPipeModule } from '@taiga-ui/core';\nimport { filter, map, tap, switchMap, startWith, takeUntil, repeat } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@taiga-ui/kit/components/slider';\nimport * as ɵngcc2 from '@angular/forms';\nimport * as ɵngcc3 from '@taiga-ui/cdk';\nimport * as ɵngcc4 from '@angular/common';\nimport * as ɵngcc5 from '@taiga-ui/core';\nimport * as ɵngcc6 from 'rxjs';\n\nfunction TuiRangeComponent_div_3_span_1_ng_container_1_span_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵpipe(2, \"i18nPlural\");\n    ɵngcc0.ɵɵpipe(3, \"tuiSliderTickLabel\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const tickIndex_r2 = ɵngcc0.ɵɵnextContext(3).$implicit;\n    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ɵngcc0.ɵɵpipeBind2(2, 1, ɵngcc0.ɵɵpipeBind3(3, 4, tickIndex_r2, ctx_r6.segments, ctx_r6.computedKeySteps), ctx_r6.pluralizeMap), \" \");\n  }\n}\n\nfunction TuiRangeComponent_div_3_span_1_ng_container_1_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 9);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵpipe(2, \"tuiFormatNumber\");\n    ɵngcc0.ɵɵpipe(3, \"tuiSliderTickLabel\");\n    ɵngcc0.ɵɵtemplate(4, TuiRangeComponent_div_3_span_1_ng_container_1_span_1_span_4_Template, 4, 8, \"span\", 7);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const fromToText_r4 = ɵngcc0.ɵɵnextContext().ngIf;\n    const tickIndex_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate2(\" \", ctx_r5.getSegmentPrefix(tickIndex_r2, fromToText_r4), \" \", ɵngcc0.ɵɵpipeBind1(2, 3, ɵngcc0.ɵɵpipeBind3(3, 5, tickIndex_r2, ctx_r5.segments, ctx_r5.computedKeySteps)), \" \");\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.pluralizeMap);\n  }\n}\n\nfunction TuiRangeComponent_div_3_span_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TuiRangeComponent_div_3_span_1_ng_container_1_span_1_Template, 5, 9, \"span\", 8);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r3.isNew);\n  }\n}\n\nfunction TuiRangeComponent_div_3_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 6);\n    ɵngcc0.ɵɵtemplate(1, TuiRangeComponent_div_3_span_1_ng_container_1_Template, 2, 1, \"ng-container\", 7);\n    ɵngcc0.ɵɵpipe(2, \"async\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r1.fromToTexts$));\n  }\n}\n\nfunction TuiRangeComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 4);\n    ɵngcc0.ɵɵtemplate(1, TuiRangeComponent_div_3_span_1_Template, 3, 3, \"span\", 5);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"tuiRepeatTimesOf\", ctx_r0.segments + 1);\n  }\n}\n\nvar TuiRangeComponent_1;\n/**\n * Turn on new mode for `Range` and `InputRange`.\n * The new version of component will behave almost the same as the same component from the next major release.\n * @deprecated TODO remove me in v3.0 and make `Range` and `InputRange` always \"new\".\n */\n\nlet TuiNewRangeDirective = /*#__PURE__*/(() => {\n  let TuiNewRangeDirective = class TuiNewRangeDirective {};\n\n  TuiNewRangeDirective.ɵfac = function TuiNewRangeDirective_Factory(t) {\n    return new (t || TuiNewRangeDirective)();\n  };\n\n  TuiNewRangeDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TuiNewRangeDirective,\n    selectors: [[\"tui-range\", \"new\", \"\"], [\"tui-input-range\", \"new\", \"\"]]\n  }); // @dynamic\n\n  return TuiNewRangeDirective;\n})();\nlet TuiRangeComponent = TuiRangeComponent_1 =\n/**\n * `AbstractTuiSlider` includes all legacy code (it can be deleted in v3.0)\n * TODO replace `extends AbstractTuiSlider<[number, number]>` by `extends AbstractTuiControl<[number, number]> implements TuiWithOptionalMinMax<number>, TuiFocusableElementAccessor`\n */\nclass TuiRangeComponent extends AbstractTuiSlider {\n  constructor(control, changeDetectorRef, documentRef, elementRef, fromToTexts$, isNew) {\n    super(control, changeDetectorRef, documentRef, fromToTexts$);\n    this.elementRef = elementRef;\n    this.isNew = isNew;\n    this.min = 0;\n    /**\n     * TODO: make `100` as default value (to be like native sliders) in v3.0\n     */\n\n    this.max = Infinity;\n    /**\n     * TODO: think about replacing this props by `step` (to be like native slider).\n     * It can be done after removing backward compatibility code inside {@link computePureKeySteps} in v3.0\n     */\n\n    this.steps = 0;\n    /**\n     * TODO: think about replacing this props by `step` (to be like native slider).\n     * It can be done after removing backward compatibility code inside {@link computePureKeySteps} in v3.0\n     * */\n\n    this.quantum = 0;\n    this.size = 'm';\n    this.segments = 0;\n    this.keySteps = null;\n    this.slidersRefs = EMPTY_QUERY;\n    this.lastActiveThumb = 'right';\n  }\n\n  get nativeFocusableElement() {\n    const [sliderLeftRef, sliderRightRef] = this.slidersRefs;\n\n    if (this.computedDisabled || !sliderLeftRef || !sliderRightRef) {\n      return null;\n    }\n\n    return this.isLeftFocusable ? sliderLeftRef.nativeElement : sliderRightRef.nativeElement;\n  }\n\n  get focused() {\n    return isNativeFocusedIn(this.elementRef.nativeElement);\n  }\n\n  get fractionStep() {\n    if (this.steps) {\n      return 1 / this.steps;\n    }\n\n    return this.quantum ? this.quantum / (this.max - this.min) : SLIDER_KEYBOARD_STEP;\n  }\n\n  get computedKeySteps() {\n    return this.computePureKeySteps(this.keySteps, this.min, this.max);\n  }\n\n  get left() {\n    return this.getPercentageFromValue(this.value[0]);\n  }\n\n  get right() {\n    return 100 - this.getPercentageFromValue(this.value[1]);\n  }\n\n  onFocused(focused) {\n    this.updateFocused(focused);\n  }\n\n  changeByStep(coefficient, target) {\n    const [sliderLeftRef, sliderRightRef] = this.slidersRefs;\n    const leftThumbElement = sliderLeftRef.nativeElement;\n    const rightThumbElement = sliderRightRef.nativeElement;\n    const isRightThumb = target === this.elementRef.nativeElement ? this.lastActiveThumb === 'right' : target === rightThumbElement;\n    const activeThumbElement = isRightThumb ? rightThumbElement : leftThumbElement;\n    const previousValue = isRightThumb ? this.value[1] : this.value[0];\n    /** @bad TODO think about a solution without twice conversion */\n\n    const previousFraction = this.getPercentageFromValue(previousValue) / 100;\n    const newFractionValue = previousFraction + coefficient * this.fractionStep;\n    this.processValue(this.getValueFromFraction(newFractionValue), isRightThumb);\n\n    if (activeThumbElement) {\n      activeThumbElement.focus();\n    }\n  }\n\n  processValue(value, right) {\n    const guardedValue = this.valueGuard(value);\n\n    if (right) {\n      this.updateEnd(guardedValue);\n    } else {\n      this.updateStart(guardedValue);\n    }\n\n    this.lastActiveThumb = right ? 'right' : 'left';\n  }\n\n  fractionGuard(fraction) {\n    return clamp(quantize(fraction, this.fractionStep), 0, 1);\n  }\n\n  getValueFromFraction(fraction) {\n    const percentage = this.fractionGuard(fraction) * 100;\n    return tuiPercentageToKeyStepValue(percentage, this.computedKeySteps);\n  }\n\n  getPercentageFromValue(value) {\n    return tuiKeyStepValueToPercentage(value, this.computedKeySteps);\n  }\n\n  valueGuard(value) {\n    return clamp(this.quantum ? round(Math.round(value / this.quantum) * this.quantum, TUI_FLOATING_PRECISION) : value, this.min, this.max);\n  }\n\n  getFallbackValue() {\n    return [0, 0];\n  }\n\n  computePureKeySteps(keySteps, min, max) {\n    if (keySteps && tuiCheckKeyStepsHaveMinMaxPercents(keySteps)) {\n      return keySteps;\n    } // TODO replace all function by `return keySteps || [[0, min], [100, max]]` in v3.0\n\n\n    tuiAssert.assert(!keySteps, '\\n' + 'Input property [keySteps] should contain min and max percents.\\n' + 'We have taken [min] and [max] properties of your component for now (but it will not work in v3.0).\\n' + 'See example how properly use [keySteps]: https://taiga-ui.dev/components/range#key-steps');\n    return [[0, min], ...(keySteps || []), [100, max]];\n  }\n\n  updateStart(value) {\n    this.updateValue([Math.min(value, this.value[1]), this.value[1]]);\n  }\n\n  updateEnd(value) {\n    this.updateValue([this.value[0], Math.max(value, this.value[0])]);\n  }\n\n};\n\nTuiRangeComponent.ɵfac = function TuiRangeComponent_Factory(t) {\n  return new (t || TuiRangeComponent)(ɵngcc0.ɵɵdirectiveInject(NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(TUI_FROM_TO_TEXTS), ɵngcc0.ɵɵdirectiveInject(TuiNewRangeDirective, 8));\n};\n\nTuiRangeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: TuiRangeComponent,\n  selectors: [[\"tui-range\"]],\n  viewQuery: function TuiRangeComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(TuiSliderComponent, 5, ElementRef);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.slidersRefs = _t);\n    }\n  },\n  hostVars: 7,\n  hostBindings: function TuiRangeComponent_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"focusin\", function TuiRangeComponent_focusin_HostBindingHandler() {\n        return ctx.onFocused(true);\n      })(\"focusout\", function TuiRangeComponent_focusout_HostBindingHandler() {\n        return ctx.onFocused(false);\n      })(\"keydown.arrowUp.prevent\", function TuiRangeComponent_keydown_arrowUp_prevent_HostBindingHandler($event) {\n        return ctx.changeByStep(1, $event.target);\n      })(\"keydown.arrowRight.prevent\", function TuiRangeComponent_keydown_arrowRight_prevent_HostBindingHandler($event) {\n        return ctx.changeByStep(1, $event.target);\n      })(\"keydown.arrowLeft.prevent\", function TuiRangeComponent_keydown_arrowLeft_prevent_HostBindingHandler($event) {\n        return ctx.changeByStep(-1, $event.target);\n      })(\"keydown.arrowDown.prevent\", function TuiRangeComponent_keydown_arrowDown_prevent_HostBindingHandler($event) {\n        return ctx.changeByStep(-1, $event.target);\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"tabindex\", -1)(\"aria-disabled\", ctx.computedDisabled)(\"data-size\", ctx.size);\n      ɵngcc0.ɵɵstyleProp(\"--left\", ctx.left, \"%\")(\"--right\", ctx.right, \"%\");\n    }\n  },\n  inputs: {\n    min: \"min\",\n    max: \"max\",\n    steps: \"steps\",\n    quantum: \"quantum\",\n    size: \"size\",\n    segments: \"segments\",\n    keySteps: \"keySteps\"\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: TUI_FOCUSABLE_ITEM_ACCESSOR,\n    useExisting: forwardRef(() => TuiRangeComponent_1)\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n  decls: 4,\n  vars: 15,\n  consts: [[1, \"track\"], [\"tuiSlider\", \"\", \"readonly\", \"\", \"type\", \"range\", \"step\", \"any\", \"automation-id\", \"tui-range__left\", 1, \"thumb\", 3, \"min\", \"max\", \"ngModel\", \"size\", \"keySteps\", \"tuiFocusable\"], [\"tuiSlider\", \"\", \"readonly\", \"\", \"type\", \"range\", \"step\", \"any\", \"automation-id\", \"tui-range__right\", 1, \"thumb\", 3, \"min\", \"max\", \"ngModel\", \"size\", \"keySteps\", \"tuiFocusable\"], [\"class\", \"segments\", 4, \"ngIf\"], [1, \"segments\"], [\"automation-id\", \"tui-slider__segment\", \"class\", \"segment\", 4, \"tuiRepeatTimes\", \"tuiRepeatTimesOf\"], [\"automation-id\", \"tui-slider__segment\", 1, \"segment\"], [4, \"ngIf\"], [\"class\", \"number\", 4, \"ngIf\"], [1, \"number\"]],\n  template: function TuiRangeComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n      ɵngcc0.ɵɵelement(1, \"input\", 1);\n      ɵngcc0.ɵɵelement(2, \"input\", 2);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵtemplate(3, TuiRangeComponent_div_3_Template, 2, 1, \"div\", 3);\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"min\", ctx.min)(\"max\", ctx.max)(\"ngModel\", ctx.value[0])(\"size\", ctx.size)(\"keySteps\", ctx.computedKeySteps)(\"tuiFocusable\", ctx.focusable);\n      ɵngcc0.ɵɵattribute(\"disabled\", ctx.computedDisabled || null);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"min\", ctx.min)(\"max\", ctx.max)(\"ngModel\", ctx.value[1])(\"size\", ctx.size)(\"keySteps\", ctx.computedKeySteps)(\"tuiFocusable\", ctx.focusable);\n      ɵngcc0.ɵɵattribute(\"disabled\", ctx.computedDisabled || null);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.segments > 0);\n    }\n  },\n  directives: [ɵngcc1.TuiSliderReadonlyDirective, ɵngcc1.TuiSliderKeyStepsDirective, ɵngcc1.TuiSliderComponent, ɵngcc2.RangeValueAccessor, ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, ɵngcc3.TuiFocusableDirective, ɵngcc4.NgIf, ɵngcc3.TuiRepeatTimesDirective],\n  pipes: [ɵngcc4.AsyncPipe, ɵngcc5.TuiFormatNumberPipe, ɵngcc1.TuiSliderTickLabelPipe, ɵngcc4.I18nPluralPipe],\n  styles: [\"[_nghost-%COMP%]{position:relative;display:block;height:.125rem;border-radius:var(--tui-radius-m);background:var(--tui-base-03);cursor:pointer;outline:0;margin:.4375rem 0;touch-action:pan-x}[_nghost-%COMP%]:active{cursor:ew-resize}[_nghost-%COMP%]:after{content:'';position:absolute;top:-.4375rem;bottom:-.4375rem;width:100%}._disabled[_nghost-%COMP%]{opacity:var(--tui-disabled-opacity);cursor:auto}[data-size='s'][_nghost-%COMP%]   .track[_ngcontent-%COMP%]{position:relative;margin:0 .25rem;height:100%}[data-size='s'][_nghost-%COMP%]   .track[_ngcontent-%COMP%]:after{content:'';position:absolute;top:0;left:var(--left);right:var(--right);height:100%;background:var(--tui-primary);margin:0 -.25rem}[data-size='m'][_nghost-%COMP%]   .track[_ngcontent-%COMP%]{position:relative;margin:0 .5rem;height:100%}[data-size='m'][_nghost-%COMP%]   .track[_ngcontent-%COMP%]:after{content:'';position:absolute;top:0;left:var(--left);right:var(--right);height:100%;background:var(--tui-primary);margin:0 -.5rem}.thumb[_ngcontent-%COMP%]{pointer-events:none;position:absolute;top:.0625rem;left:0;right:0;z-index:1;transform:translate(0,-50%)}.thumb[_ngcontent-%COMP%]::-webkit-slider-thumb{pointer-events:all}.thumb[_ngcontent-%COMP%]::-moz-range-thumb{pointer-events:all}input[type=range].thumb[_ngcontent-%COMP%]::-webkit-slider-runnable-track{background:0 0}input[type=range].thumb[_ngcontent-%COMP%]::-moz-range-track{background:0 0}input[type=range].thumb[_ngcontent-%COMP%]::-moz-range-progress{background:0 0}input[type=range].thumb[_ngcontent-%COMP%]::-ms-track{background:0 0}input[type=range].thumb[_ngcontent-%COMP%]::-ms-fill-lower{background:0 0}.thumb[_ngcontent-%COMP%]:last-of-type::-webkit-slider-thumb{transform:translate(50%,0)}.thumb[_ngcontent-%COMP%]:first-of-type::-webkit-slider-thumb{transform:translate(-50%,0)}.thumb[_ngcontent-%COMP%]:last-of-type::-moz-range-thumb{transform:translate(50%,0)}.thumb[_ngcontent-%COMP%]:first-of-type::-moz-range-thumb{transform:translate(-50%,0)}._disabled[_nghost-%COMP%]   .thumb[_ngcontent-%COMP%]{opacity:1}.segments[_ngcontent-%COMP%]{position:absolute;top:0;left:0;bottom:0;right:0}[data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%]{display:flex;margin:0 .25rem;font:var(--tui-font-text-s);padding:0 .25rem}[data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{position:relative;flex:2;text-align:center}[data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:first-child{left:-.25rem;flex:1;text-align:left}[data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:last-child{right:-.25rem;flex:1;text-align:right}tui-input-slider + [data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%]{margin-left:calc(var(--tui-radius-m)/ 2 + .25rem)}tui-input-range + [data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%], tui-range + [data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%]{margin-left:.5rem;margin-right:.5rem}tui-input-range + [data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:first-child, tui-range + [data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:first-child{left:-.5rem}tui-input-range + [data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:last-child, tui-range + [data-size='s'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:last-child{right:-.5rem}[data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%]{display:flex;margin:0 .5rem;font:var(--tui-font-text-s);padding:0 .5rem}[data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{position:relative;flex:2;text-align:center}[data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:first-child{left:-.5rem;flex:1;text-align:left}[data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:last-child{right:-.5rem;flex:1;text-align:right}tui-input-slider + [data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%]{margin-left:calc(var(--tui-radius-m)/ 2 + .5rem)}tui-input-range + [data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%], tui-range + [data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%]{margin-left:1rem;margin-right:1rem}tui-input-range + [data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:first-child, tui-range + [data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:first-child{left:-1rem}tui-input-range + [data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:last-child, tui-range + [data-size='m'][_nghost-%COMP%]   .segments[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:last-child{right:-1rem}.segment[_ngcontent-%COMP%]:not(:last-of-type):not(:first-of-type):before{content:'';position:absolute;left:0;right:0;margin:auto;background:var(--tui-base-07);width:.25rem;height:100%}.segment[_ngcontent-%COMP%]:last-of-type   .number[_ngcontent-%COMP%]{margin-right:-.5rem}.segment[_ngcontent-%COMP%]:first-of-type   .number[_ngcontent-%COMP%]{margin-left:-.5rem}.number[_ngcontent-%COMP%]{display:inline-block;margin-top:.5rem}\"],\n  changeDetection: 0\n});\n\nTuiRangeComponent.ctorParameters = () => [{\n  type: NgControl,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Self\n  }, {\n    type: Inject,\n    args: [NgControl]\n  }]\n}, {\n  type: ChangeDetectorRef,\n  decorators: [{\n    type: Inject,\n    args: [ChangeDetectorRef]\n  }]\n}, {\n  type: Document,\n  decorators: [{\n    type: Inject,\n    args: [DOCUMENT]\n  }]\n}, {\n  type: ElementRef,\n  decorators: [{\n    type: Inject,\n    args: [ElementRef]\n  }]\n}, {\n  type: Observable,\n  decorators: [{\n    type: Inject,\n    args: [TUI_FROM_TO_TEXTS]\n  }]\n}, {\n  type: TuiNewRangeDirective,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [TuiNewRangeDirective]\n  }]\n}];\n\n__decorate([Input(), tuiDefaultProp()], TuiRangeComponent.prototype, \"min\", void 0);\n\n__decorate([Input(), tuiDefaultProp()], TuiRangeComponent.prototype, \"max\", void 0);\n\n__decorate([Input(), tuiDefaultProp()], TuiRangeComponent.prototype, \"steps\", void 0);\n\n__decorate([Input(), tuiDefaultProp(nonNegativeFiniteAssertion, 'Quantum must be a non-negative number')], TuiRangeComponent.prototype, \"quantum\", void 0);\n\n__decorate([Input(), HostBinding('attr.data-size'), tuiDefaultProp()], TuiRangeComponent.prototype, \"size\", void 0);\n\n__decorate([Input(), tuiDefaultProp()], TuiRangeComponent.prototype, \"segments\", void 0);\n\n__decorate([Input(), tuiDefaultProp()], TuiRangeComponent.prototype, \"keySteps\", void 0);\n\n__decorate([ViewChildren(TuiSliderComponent, {\n  read: ElementRef\n})], TuiRangeComponent.prototype, \"slidersRefs\", void 0);\n\n__decorate([HostBinding('style.--left.%')], TuiRangeComponent.prototype, \"left\", null);\n\n__decorate([HostBinding('style.--right.%')], TuiRangeComponent.prototype, \"right\", null);\n\n__decorate([HostListener('focusin', ['true']), HostListener('focusout', ['false'])], TuiRangeComponent.prototype, \"onFocused\", null);\n\n__decorate([HostListener('keydown.arrowUp.prevent', ['1', '$event.target']), HostListener('keydown.arrowRight.prevent', ['1', '$event.target']), HostListener('keydown.arrowLeft.prevent', ['-1', '$event.target']), HostListener('keydown.arrowDown.prevent', ['-1', '$event.target'])], TuiRangeComponent.prototype, \"changeByStep\", null);\n\n__decorate([tuiPure], TuiRangeComponent.prototype, \"computePureKeySteps\", null);\n\nTuiRangeComponent = TuiRangeComponent_1 = __decorate([__param(0, Optional()), __param(0, Self()), __param(0, Inject(NgControl)), __param(1, Inject(ChangeDetectorRef)), __param(2, Inject(DOCUMENT)), __param(3, Inject(ElementRef)), __param(4, Inject(TUI_FROM_TO_TEXTS)), __param(5, Optional()), __param(5, Inject(TuiNewRangeDirective))], TuiRangeComponent); // @dynamic\n\nlet TuiRangeChangeDirective = /*#__PURE__*/(() => {\n  let TuiRangeChangeDirective = class TuiRangeChangeDirective {\n    constructor(documentRef, elementRef, range, destroy$) {\n      this.documentRef = documentRef;\n      this.elementRef = elementRef;\n      this.range = range;\n      /**\n       * TODO replace with pointer events (when all supported browsers can handle them).\n       * Dont forget to use setPointerCapture instead of listening all documentRef events\n       */\n\n      this.pointerDown$ = merge(typedFromEvent(this.elementRef.nativeElement, 'touchstart', {\n        passive: true\n      }).pipe(filter(({\n        touches\n      }) => touches.length === 1), map(({\n        touches\n      }) => touches[0])), typedFromEvent(this.elementRef.nativeElement, 'mousedown', {\n        passive: true\n      }));\n      this.pointerMove$ = merge(typedFromEvent(this.documentRef, 'touchmove').pipe(filter(({\n        touches\n      }) => touches.length === 1), map(({\n        touches\n      }) => touches[0])), typedFromEvent(this.documentRef, 'mousemove'));\n      this.pointerUp$ = merge(typedFromEvent(this.documentRef, 'touchend', {\n        passive: true\n      }), typedFromEvent(this.documentRef, 'mouseup', {\n        passive: true\n      }));\n      this.activeThumbChange = new EventEmitter();\n      let activeThumb;\n      this.pointerDown$.pipe(tap(({\n        clientX,\n        target\n      }) => {\n        activeThumb = this.detectActiveThumb(clientX, target);\n        this.activeThumbChange.emit(activeThumb);\n        elementRef.nativeElement.focus();\n      }), switchMap(event => this.pointerMove$.pipe(startWith(event))), map(({\n        clientX\n      }) => clamp(this.getFractionFromEvents(clientX), 0, 1)), takeUntil(this.pointerUp$), repeat(), takeUntil(destroy$)).subscribe(fraction => {\n        const value = this.range.getValueFromFraction(this.range.fractionGuard(fraction));\n        this.range.processValue(value, activeThumb === 'right');\n      });\n    }\n\n    getFractionFromEvents(clickClientX) {\n      const hostRect = this.elementRef.nativeElement.getBoundingClientRect();\n      const value = clickClientX - hostRect.left;\n      const total = hostRect.width;\n      return round(value / total, TUI_FLOATING_PRECISION);\n    }\n\n    detectActiveThumb(clientX, target) {\n      const [leftSliderRef, rightSliderRef] = this.range.slidersRefs;\n\n      switch (target) {\n        case leftSliderRef.nativeElement:\n          return 'left';\n\n        case rightSliderRef.nativeElement:\n          return 'right';\n\n        default:\n          return this.findNearestActiveThumb(clientX);\n      }\n    }\n\n    findNearestActiveThumb(clientX) {\n      const fraction = this.getFractionFromEvents(clientX);\n      const deltaLeft = fraction * 100 - this.range.left;\n      const deltaRight = fraction * 100 - 100 + this.range.right;\n      return Math.abs(deltaLeft) > Math.abs(deltaRight) || deltaRight > 0 || this.range.left === 0 && this.range.right === 100 ? 'right' : 'left';\n    }\n\n  };\n\n  TuiRangeChangeDirective.ɵfac = function TuiRangeChangeDirective_Factory(t) {\n    return new (t || TuiRangeChangeDirective)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(TuiRangeComponent), ɵngcc0.ɵɵdirectiveInject(TuiDestroyService));\n  };\n\n  TuiRangeChangeDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TuiRangeChangeDirective,\n    selectors: [[\"tui-range\"]],\n    outputs: {\n      activeThumbChange: \"activeThumbChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([TuiDestroyService])]\n  });\n\n  __decorate([Output()], TuiRangeChangeDirective.prototype, \"activeThumbChange\", void 0);\n\n  TuiRangeChangeDirective = __decorate([__param(0, Inject(DOCUMENT)), __param(1, Inject(ElementRef)), __param(2, Inject(TuiRangeComponent)), __param(3, Inject(TuiDestroyService))], TuiRangeChangeDirective);\n  return TuiRangeChangeDirective;\n})();\nlet TuiRangeModule = /*#__PURE__*/(() => {\n  let TuiRangeModule = class TuiRangeModule {};\n\n  TuiRangeModule.ɵfac = function TuiRangeModule_Factory(t) {\n    return new (t || TuiRangeModule)();\n  };\n\n  TuiRangeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TuiRangeModule\n  });\n  TuiRangeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, TuiRepeatTimesModule, TuiFocusableModule, TuiFormatNumberPipeModule, TuiSliderModule, FormsModule]]\n  });\n  return TuiRangeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TuiRangeModule, {\n    declarations: function () {\n      return [TuiRangeComponent, TuiRangeChangeDirective, TuiNewRangeDirective];\n    },\n    imports: function () {\n      return [CommonModule, TuiRepeatTimesModule, TuiFocusableModule, TuiFormatNumberPipeModule, TuiSliderModule, FormsModule];\n    },\n    exports: function () {\n      return [TuiRangeComponent, TuiRangeChangeDirective, TuiNewRangeDirective];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TuiNewRangeDirective, TuiRangeChangeDirective, TuiRangeComponent, TuiRangeModule }; //# sourceMappingURL=taiga-ui-kit-components-range.js.map","map":null,"metadata":{},"sourceType":"module"}